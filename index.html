/* --- 改良ポイント: 入力補完とチェック --- */
function check() {
  if (!hasGrid()) return;

  const cells = document.querySelectorAll(".cell");
  let okCount = 0;
  let emptyCount = 0; // 未入力カウント

  for (const cell of cells) {
    const r = Number(cell.dataset.r);
    const c = Number(cell.dataset.c);
    const idx = r * SIZE + c;
    const inp = cell.querySelector("input");
    const raw = inp.value.trim();
    
    if (raw === "") {
      emptyCount++;
      cell.classList.remove("bad", "firstOk", "lateOk");
      continue;
    }

    const v = Number(raw);
    const correct = (Number.isFinite(v) && v === answers[r][c]);

    if (correct) {
      if (!solved[idx]) {
        solved[idx] = true;
        const isFirstTry = (wrongChecks[idx] === 0) && !usedPeek[idx];
        cell.classList.add(isFirstTry ? "firstOk" : "lateOk");
      }
      okCount++;
    } else {
      wrongChecks[idx]++;
      cell.classList.add("bad");
      cell.classList.remove("firstOk", "lateOk");
    }
  }

  const score = Math.round((okCount / (SIZE * SIZE)) * 100);
  document.getElementById("score").textContent = `点数：${score} / 100`;

  // 全問正解でなくても、入力があればタイマー停止を検討するか
  // 現状通り allCorrect() で判定
  maybeStopTimerIfAllCorrect();
}

/* --- 改良ポイント: キーボード操作の循環 --- */
function focusByIndex(index) {
  const inputs = getInputs();
  if (inputs.length === 0) return;
  
  // 最後のマスでEnterを押した場合の処理
  if (index >= inputs.length) {
    document.getElementById("checkBtn").focus(); // こたえあわせボタンへ
    return;
  }
  
  const i = (index + inputs.length) % inputs.length;
  inputs[i].focus();
  inputs[i].select?.();
}
